#!/usr/bin/env python3
import os
import subprocess
import shutil
import time
from contextlib import contextmanager

# Generated by Anthropic Claude.

class ChrootUpdateError(Exception):
    """Custom exception for chroot update errors"""
    pass

def remount_host_filesystems():
    """Remount essential filesystems on host after chroot"""
    try:
        # Ensure /dev/pts exists
        os.makedirs('/dev/pts', exist_ok=True)

        # Check if devpts is already mounted
        result = subprocess.run(['mountpoint', '-q', '/dev/pts'])
        if result.returncode != 0:
            # Remount devpts
            subprocess.run(
                ['mount', '-t', 'devpts', '-o', 'gid=5,mode=620', 'devpts', '/dev/pts'],
                check=True
            )
            print("Remounted devpts filesystem")
        else:
            print("devpts already mounted")

    except subprocess.CalledProcessError as e:
        print(f"Warning: Failed to remount filesystems: {e}")
    except Exception as e:
        print(f"Warning: Unexpected error during filesystem remount: {e}")

@contextmanager
def mount_context(rootfs_path):
    """Context manager to handle mounting and unmounting of necessary filesystems"""
    mounted_paths = []

    try:
        # Define mount points: (name, destination, mount_args, make_rslave)
        mount_points = [
            ('proc', os.path.join(rootfs_path, 'proc'), ['-t', 'proc', 'proc'], False),
            ('sys', os.path.join(rootfs_path, 'sys'), ['--rbind', '/sys'], True),
            ('dev', os.path.join(rootfs_path, 'dev'), ['--rbind', '/dev'], True),
            ('run', os.path.join(rootfs_path, 'run'), ['--rbind', '/run'], True),
        ]

        # Perform mounts
        for name, dest, options, make_rslave in mount_points:
            os.makedirs(dest, exist_ok=True)
            subprocess.run(['mount'] + options + [dest], check=True)
            if make_rslave:
                subprocess.run(['mount', '--make-rslave', dest], check=True)
            mounted_paths.append(dest)
            print(f"Mounted {name} at {dest}")

        # Mount devpts separately (needs the directory from dev bind mount to exist first)
        devpts_dest = os.path.join(rootfs_path, 'dev/pts')
        os.makedirs(devpts_dest, exist_ok=True)
        subprocess.run(['mount', '-t', 'devpts', '-o', 'gid=5,mode=620', 'devpts', devpts_dest], check=True)
        mounted_paths.append(devpts_dest)
        print(f"Mounted devpts at {devpts_dest}")

        # Copy resolv.conf for DNS resolution
        shutil.copy2('/etc/resolv.conf', os.path.join(rootfs_path, 'etc/resolv.conf'))
        print("Copied resolv.conf for DNS resolution")

        yield

    finally:
        # Unmount everything in reverse order
        for path in reversed(mounted_paths):
            max_attempts = 3
            attempt = 0
            while attempt < max_attempts:
                try:
                    subprocess.run(['umount', '-l', path], check=True)
                    print(f"Unmounted {path}")
                    break
                except subprocess.CalledProcessError:
                    attempt += 1
                    if attempt < max_attempts:
                        print(f"Retrying unmount of {path}")
                        time.sleep(1)
                    else:
                        print(f"Warning: Failed to unmount {path}")

def run_chroot_command(rootfs_path, command):
    """Run a command in chroot environment"""
    env = os.environ.copy()
    env['DEBIAN_FRONTEND'] = 'noninteractive'
    env['LC_ALL'] = 'C'

    # For apt commands, add options to handle config file prompts automatically
    if command[0] == 'apt':
        # Insert dpkg options after 'apt' but before the subcommand
        command = [command[0]] + ['-o', 'Dpkg::Options::=--force-confdef', '-o', 'Dpkg::Options::=--force-confold'] + command[1:]

    result = subprocess.run(['chroot', rootfs_path] + command,
                            env=env, text=True)

    print(f"Command output:")
    print(result.stdout)

    if result.stderr:
        print(f"Command errors:")
        print(result.stderr)

    if result.returncode != 0:
        raise ChrootUpdateError(
            f"Command {' '.join(command)} failed with return code {result.returncode}")

def update_system(rootfs_path):
    """Perform system update in chroot environment"""
    if not os.path.isdir(rootfs_path):
        raise ValueError(f"Root filesystem path {rootfs_path} does not exist")

    if os.geteuid() != 0:
        raise PermissionError("This script must be run as root")

    print(f"Starting system update in {rootfs_path}")

    with mount_context(rootfs_path):
        try:
            # Update package lists
            print("\nUpdating package lists...")
            run_chroot_command(rootfs_path, ['apt', 'update'])

            # Perform full upgrade
            print("\nPerforming full upgrade...")
            run_chroot_command(rootfs_path, [
                'env', 'DEBIAN_FRONTEND=noninteractive',
                'apt', 'full-upgrade', '-y',
                '-o', 'Dpkg::Options::=--force-confdef',
                '-o', 'Dpkg::Options::=--force-confold'
            ])

            # While we're at it...
            print("\nInstalling mDNS/Bonjour support...")
            run_chroot_command(rootfs_path, ['apt', 'install', '-y', 'avahi-daemon'])

            print("\nInstalling math support...")
            run_chroot_command(rootfs_path, ['apt', 'install', '-y', 'libblas-dev'])
            run_chroot_command(rootfs_path,
                               ['apt', 'install', '-y', 'libatlas-base-dev:armhf'])
            run_chroot_command(rootfs_path,
                               ['apt', 'install', '-y', 'libatlas-base-dev'])
            run_chroot_command(rootfs_path, ['apt', 'install', '-y', 'liblapack-dev'])

            print("\nInstalling libssl-dev...")
            run_chroot_command(rootfs_path, ['apt', 'install', '-y', 'libssl-dev'])

            print("\nInstalling i2c tools...")
            run_chroot_command(rootfs_path, ['apt', 'install', '-y', 'i2c-tools'])

            print("\nInstalling python deps and grpc...")
            run_chroot_command(rootfs_path, ['apt', 'install', '-y', 'build-essential'])
            run_chroot_command(rootfs_path, ['apt', 'install', '-y', 'python3-dev'])
            run_chroot_command(rootfs_path, ['apt', 'install', '-y', 'cmake'])
            run_chroot_command(rootfs_path, ['apt', 'install', '-y', 'pkg-config'])
            run_chroot_command(rootfs_path, ['apt', 'install', '-y', 'libjpeg-dev'])
            run_chroot_command(rootfs_path, ['apt', 'install', '-y', 'zlib1g-dev'])
            run_chroot_command(rootfs_path, ['apt', 'install', '-y', 'libfreetype6-dev'])
            run_chroot_command(rootfs_path, ['apt', 'install', '-y', 'liblcms2-dev'])
            run_chroot_command(rootfs_path, ['apt', 'install', '-y', 'libopenjp2-7-dev'])
            run_chroot_command(rootfs_path, ['apt', 'install', '-y', 'libtiff5-dev'])
            run_chroot_command(rootfs_path, ['apt', 'install', '-y', 'tk-dev'])
            run_chroot_command(rootfs_path, ['apt', 'install', '-y', 'libharfbuzz-dev'])
            run_chroot_command(rootfs_path, ['apt', 'install', '-y', 'libfribidi-dev'])
            run_chroot_command(rootfs_path, ['apt', 'install', '-y', 'python3-grpcio'])
            run_chroot_command(rootfs_path, ['apt', 'install', '-y', 'python3-grpc-tools'])
            run_chroot_command(rootfs_path, ['apt', 'install', '-y', 'pip'])

            # Clean up
            print("\nCleaning up...")
            run_chroot_command(rootfs_path, ['apt', 'clean'])

            print("\nSystem update completed successfully")

        except ChrootUpdateError as e:
            print(f"\nError during update: {e}")
            raise
        except Exception as e:
            print(f"\nUnexpected error: {e}")
            raise

    # After chroot is done and filesystems are unmounted, remount host filesystems
    print("\nRestoring host system mounts...")
    remount_host_filesystems()

def main():
    ROOTFS_PATH = "/mnt/part2"
    policy_file = os.path.join(ROOTFS_PATH, 'usr/sbin/policy-rc.d')

    try:
        # Create policy-rc.d to prevent services from starting
        os.makedirs(os.path.dirname(policy_file), exist_ok=True)
        with open(policy_file, 'w') as f:
            f.write('#!/bin/sh\nexit 101\n')
        os.chmod(policy_file, 0o755)
        print(f"Created policy-rc.d")

        update_system(ROOTFS_PATH)

    except Exception as e:
        print(f"Failed to update system: {e}")
        exit(1)
    finally:
        # Clean up policy-rc.d
        if os.path.exists(policy_file):
            os.remove(policy_file)
            print(f"Removed policy-rc.d")

if __name__ == "__main__":
    main()
